#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;

my $outFile = '-';
my $skipMinus;

GetOptions(
    "o|out-file:s"  => \$outFile,
    "skip-minus!"   => \$skipMinus
);

my $seqFile = shift or usage();

my $inFh = _open_file($seqFile);
my $outFh = _open_file($outFile, ">");

warn "Job started at ".localtime()."\n";

print { $outFh->{'_handle'} } 
    "# Generated by $0\n";
print { $outFh->{'_handle'} } 
    join("\t", qw/#seqName pos strand type C3context C5context/), "\n";

while(my $seq = _next_seq($inFh)) {
    #next unless $seq->{name}; # maybe an empty sequence
    my $strand = '+'; 
    my $cnt = find_and_output($seq, $strand);
    warn "[INFO] seq: $seq->{name}, strand: $strand, total Cs:$cnt->{total}, ".
        "CG:$cnt->{CG}, CHG:$cnt->{CHG}, CHH:$cnt->{CHH}\n";
    next if($skipMinus);
    $strand = '-';
    $cnt = find_and_output($seq, $strand);
    warn "[INFO] seq: $seq->{name}, strand: $strand, total Cs:$cnt->{total}, ".
        "CG:$cnt->{CG}, CHG:$cnt->{CHG}, CHH:$cnt->{CHH}\n";
}

_close($inFh);
_close($outFh);

warn "Job done at ".localtime()."\n";

exit 0;

sub _close {
    my $fhObj = shift;

    close($fhObj->{'_handle'});
}

sub _open_file {
    my ($f, $mode) = @_;
    $mode ||= '<';
    my $fh;
    open($fh, "$mode $f") or die "Can't open '$f' with mode '$mode':$!";
    my $fhObj = {
        '_handle' => $fh,
        '_stack'  => []
    };
    return($fhObj);
}

sub _next_line {
    my $fhObj = shift;
    if(@{$fhObj->{'_stack'}}) {
        return shift(@{$fhObj->{'_stack'}});
    }
    # otherwise read a new line
    my $fh = $fhObj->{'_handle'};
    #if(eof($fh)) { return undef; }
    return <$fh>;
}

sub _push_line {
    my $fhObj = shift;
    push @{$fhObj->{'_stack'}}, @_;
    return scalar(@_);
}

sub _next_seq {
    my $fh = shift;
    my $seq = {};
    while(my $line = _next_line($fh)) {
        if($line =~ /^>/) { # a new sequence
            if(keys(%$seq)) { # a sequence already parsed
               _push_line($fh, $line);
               last;
            } else { # start of new sequence
                $line =~ /^>(\S+)/;
                $seq->{name} = $1;
                $seq->{seq} = '';
                next;
            }
        }
        # otherwise sequence string
        next if $line =~ /^\s*$/; # remove empty lines
        chomp $line;
        # convert all bases to uppercase
        $line =~ s/\s+//g; # remove all spaces
        $seq->{seq} .= uc($line);
    }
    return keys %$seq? $seq : undef;
}

sub _write_line {
    my $line = shift;
    print { $outFh->{'_handle'} } $line, "\n";
}

sub rev_comp {
    my $seq = shift;
    $seq = reverse($seq);
    $seq =~ tr/ATCGU/TAGCA/;
    return $seq;
}

sub find_and_output {
    my $seqObj = shift;
    my $strand = shift || '+';
    my $name = $seqObj->{name};
    my $seq = $seqObj->{seq};
    $seq = rev_comp($seq) if $strand eq '-';
    my $seqLen = length($seq);
    my %cnt = ( # a hash to store counts
        total => 0,
        CG  => 0,
        CHH => 0,
        CHG => 0
    );
    return undef unless $seq; # empty string
    while($seq =~ /C/gc) {
        my $cPos = pos($seq);
        my $type = substr($seq, $cPos-1, 3);
        if( $type =~ /^CG/ ) {
            $type = 'CG';
        } elsif ($type =~ /^C.G/) {
            $type = 'CHG';
        } else {
            $type = 'CHH';
        }
        # get context
        my $c3; # CXX
        my $c5; # XXCXX
        my $s = $cPos - 3;
        my $e = $cPos + 2;
        if($e > $seqLen) { # out of boundary
            my $pad = 'X' x ($e - $seqLen);
            $c3 = substr($seq, $cPos-1).$pad;
        } else {
            $c3 = substr($seq, $cPos-1, 3);
        }
        if($s < 0) { # start out of boundary
            my $pad = 'X' x abs($s);
            $c5 = $pad.substr($seq, 0, 5 + $s);
        } else {
            $c5 = substr($seq, $cPos-3, 5);
        }
        # in case c5's 3'end is out of boundary, pad 'X'
        if(length($c5) < 5) {
            $c5 .= 'X' x (5-length($c5));
        }
        # write output
        _write_line(join("\t", $name,
                            $strand eq '-'? $seqLen+1-$cPos : $cPos,
                            $strand,
                            $type, $c3, $c5
                            #substr($seq, $cPos-1, 3),
                            #substr($seq, $cPos-3, 5)
                            )
                    );
        $cnt{total}++;
        $cnt{$type}++;
    }
    return \%cnt;
}

sub usage {
    print <<USAGE;
Usage: $0 [options] <fasta-file>

This program finds all the cytosines (base C) in input
sequences and outputs their contexts, including CNN and
NNCNN. If the contexts overflow the sequence (e.g, C is
the first base on the sequence), the contexts are padded
with character 'X'.

Options (default values are in []):

-o|--out-file <path> filename for output. [screen]

--skip-minus logical option. If provided, the Cs from minus
    strands will not be searched.

Example use:
$0 test.fa
# skip minus strand and write to a file
$0 --skip-minus -o test_out.tsv test.fa

USAGE

    exit 1;
}

